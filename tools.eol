operation Seat GetNeighbours(): Sequence {
	var maths = Native("java.lang.Math");
	var tableSeats = self.myTable.seats;
	var returned: Sequence;
	if (tableSeats.size() > 1){
	 returned = tableSeats.select(s | s.attendeeSeat.isDefined() 
						and (s.uID == maths.floorMod(self.uID+1,tableSeats.size())
							 or s.uID == maths.floorMod(self.uID-1,tableSeats.size()))).attendeeSeat;}
	return returned;
}

operation Attendee chooseFromAvailableSeats() {
	var chosenTable = System.user.choose("Choose which table", Table.All);
  				
  	if (chosenTable.isDefined()){
  		var availableSeats = chosenTable.seats.select(s | not s.attendeeSeat.isDefined());
  		if (availableSeats.size() > 0){
  			var chosenSeat = System.user.choose("Choose which seat", availableSeats);
  			if (chosenSeat.isDefined()) self.mySeat = chosenSeat;	
  		}
  		else System.user.inform("There are no available seats at this table. Add a seat to assign this attendee.");
  	} else System.user.inform("There are no available tables");
}

operation OrderedSet makeNACompatiable(): OrderedSet {
	var attendees = self.clone();
	for (at in attendees){
		if (not at.lastName.isDefined()){at.lastName = "N/A";}
		if (not at.firstName.isDefined()){at.firstName = "N/A";}
		if (not at.affiliation.isDefined()){at.affiliation = "N/A";}
		if (at.mySeat.isDefined()){
			at.~tmpMySeat = at.mySeat.uID;
			if (at.mySeat.myTable.isDefined()){
				at.~myTable = at.mySeat.myTable.uID;
			} else {at.~tmpMySeat = "N/A"; at.~myTable = "N/A";}
		} else { at.~tmpMySeat = "N/A"; at.~myTable = "N/A";}
	}
	return attendees;
}

operation Attendee isSittingNextToCommonLanguage(): Boolean {
	var neighbours = self.mySeat.GetNeighbours();
	if (neighbours.size() > 0){
		return self.spokenLanguages.exists(sl | neighbours.spokenLanguages.flatten().includes(sl));}
	else {return false;}
}

operation Attendee IsOnSameTableAs(target: Attendee): Boolean {
	return self.mySeat.myTable.seats.attendeeSeat.includes(target);
}

operation Attendee GetFailedWishes(): Map {
	var atSeats = self.mySeat.myTable.seats.attendeeSeat;
	var failedWishes = self.anttendeeWishes
						.select(aW | (aW.wish.literal == "Dislike" and atSeats.includes(aW.targetAttendee))
									 or
									 (aW.wish.literal == "Like" and not atSeats.includes(aW.targetAttendee)))
						.aggregate(aW | aW.targetAttendee, aW.wish);
	return failedWishes;
	
}

operation AttendeeWish GetAttendeeFromListBarSelf(): Sequence {
	var possibleAttendees = Attendee.all.reject(a | a == self.sourceAttendee);
	var att = System.user.choose("Choose attendees", possibleAttendees);
	var toReturn = null;
	if (att.isDefined()){toReturn = att;}
	else {System.user.inform("You have chosen no attendee");}
	return toReturn;
}


operation SeatingPlan getAllFailures(): Map {
	var failed = new Map;
	var failedWishes = new Map;
	var failedLanguages = new Map;
	
	for (at in self.attendees){
		var fails = at.GetFailedWishes();
		if (fails.size() > 0){failedWishes.put(at, fails);}
		if (at.isSittingNextToCommonLanguage()){failedLanguages.put(at, false);}
	}
	if (failedWishes.size()>0) failed.put('failedWishes', failedWishes); // att, (targetAtt, wish)
	if (failedLanguages.size()>0) failed.put('failedLanguages', failedLanguages); // att, boolean
	return failed;
}

operation Set<Attendee> hasUniqueLanguage(): Boolean {
	return self.spokenLanguages.asSet().exists(l | self.count(l)<=1);
}

operation SeatingPlan preliminaryCheckIsImpossible(): Boolean {

	for (at in self.attendees){
		// Check if any attendee can't speak to someone else
		var otherLang = self.attendees.excluding(at).spokenLanguages.flatten().name;
		if (not at.spokenLanguages.flatten().name.exists(l | otherLang.includes(l))){
			var msg = at.firstName + " " + at.lastName + " speaks language(s) that no one else understands.";
			System.user.inform(msg);
			return true;
		}
		
		// Check if any attendee likes someone who doesn't like them back
		for (_wish in at.anttendeeWishes){
			if (_wish.wish.literal == "Like" 
				and _wish.targetAttendee.anttendeeWishes.exists(w | w.targetAttendee == at and w.wish.literal == "Dislike")){
					var msg = at.firstName + " " + at.lastName + " has conflicting wishes with " + _wish.targetAttendee.firstName + " " + _wish.targetAttendee.lastName;
					System.user.inform(msg);
					return true;
				}
		}
	}
	return false;
}

operation Attendee getLikedPeople(): Set {
	return self.anttendeeWishes.select(at|at.wish.literal == "Like").targetAttendee.asSet();//.excludingAll(currentList);
}
/*
operation getAllInGroup(attendeelist: Set, finalList: Set) {
	//
	// attendeeList is a set of one Attendee to start from; finalList is a new Set
	// Recursive function to find everyone that a person wants to sit with
	// And who they want to sit with and so on. Return final list of them
	//
	var atList = attendeelist.excludingAll(finalList);
	finalList.addAll(atList);
	for (at in atList){
		var sitWith = at.getLikedPeople(finalList);
		if (sitWith.size() == 0){
			return at;
		}
		if (sitWith.size() >= 1){
			finalList.add(getAllInGroup(sitWith.clone(), finalList.clone()));
		}
	}
	return finalList;
}
*/

operation Attendee getGroupForAttendee() {
	var baseAr = new Set;
	baseAr.add(self);
	var likeAr = baseAr.clone();	
	while (likeAr.size() > 0){
		var nextGen = new Set;
		for (at in likeAr){
			var newPeop = at.getLikedPeople();
			nextGen.addAll(newPeop);
		}
		likeAr = nextGen.excludingAll(baseAr).clone();
		baseAr.addAll(likeAr.clone());
	}
	return baseAr;
}


operation SeatingPlan sortAttendees(): SeatingPlan {
	/*
	Clone all the attendees into a set
	whilst there is people still in that set, get the result from the getAllInGroup fn
	Remove the people in the result from the original cloned attendeeList
	Build up a set of sets of people that must sit with each other
	*/
	var oAttendees = self.attendees.clone().asSet().sortBy(a|a.uID);
	var gAttendees = new Sequence();
	var _group: Set;
	
	while (oAttendees.size() > 0){
		var chosenAtt = oAttendees[0];
		_group = chosenAtt.getGroupForAttendee().asSet();
		gAttendees.add(_group);
		oAttendees = oAttendees.excludingAll(_group);
	}
	gAttendees.collect(s|s.size().println());
	for (set in gAttendees){
		set.println();
	}
	
	var i = 0;
	var cap = gAttendees.collect(s|s.size()).max();
	var tables = new Set();
	for (set in gAttendees){
		
		if (not set.hasUniqueLanguage()){
			// Check if that language is spoken on another table
			// If not, then no one speasks it
			// If is, go through all the people that do and find the one that is easiest to bring over
			// If none easy, can he go to their table.
			// Language always above preferences.
			"In here".println();
			if (self.attendees.spokenLanguages){}
		} else {
			// Sort everyone by their languages
			// Seat them all down that way so at least one person speaks the same language as you do
			// Create a new seat for each of them around the table
			set = set.sortBy(a|a.spokenLanguages.sortBy(l|l.name));
			var newTable = new Table(uID=i, capacity=cap);
			var index = 0;
			var seats = new Set();
			for (at in set){
				var seat = new Seat();
				seat.myTable = newTable;
				seat.attendeeSeat = at;
				seat.uID = index;
				index += 1;
				seats.add(seat);
			}
			newTable.seats = seats;
			tables.add(newTable);
			i += 1;
		}
	}
	self.tables = tables;
}
















