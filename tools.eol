operation Seat GetNeighbours(): Sequence {
	var maths = Native("java.lang.Math");
	var tableSeats = self.myTable.seats;
	var returned: Sequence;
	if (tableSeats.size() > 1){
	 returned = tableSeats.select(s | s.attendeeSeat.isDefined() 
						and (s.uID == maths.floorMod(self.uID+1,tableSeats.size())
							 or s.uID == maths.floorMod(self.uID-1,tableSeats.size()))).attendeeSeat;}
	return returned;
}

operation Attendee chooseFromAvailableSeats() {
	var chosenTable = System.user.choose("Choose which table", Table.All);
  				
  	if (chosenTable.isDefined()){
  		var availableSeats = chosenTable.seats.select(s | not s.attendeeSeat.isDefined());
  		if (availableSeats.size() > 0){
  			var chosenSeat = System.user.choose("Choose which seat", availableSeats);
  			if (chosenSeat.isDefined()) self.mySeat = chosenSeat;	
  		}
  		else System.user.inform("There are no available seats at this table. Add a seat to assign this attendee.");
  	} else System.user.inform("There are no available tables");
}

operation OrderedSet makeNACompatiable(): OrderedSet {
	var attendees = self.clone();
	for (at in attendees){
		if (not at.lastName.isDefined()){at.lastName = "N/A";}
		if (not at.firstName.isDefined()){at.firstName = "N/A";}
		if (not at.affiliation.isDefined()){at.affiliation = "N/A";}
		if (at.mySeat.isDefined()){
			at.~tmpMySeat = at.mySeat.uID;
			if (at.mySeat.myTable.isDefined()){
				at.~myTable = at.mySeat.myTable.uID;
			} else {at.~tmpMySeat = "N/A"; at.~myTable = "N/A";}
		} else { at.~tmpMySeat = "N/A"; at.~myTable = "N/A";}
	}
	return attendees;
}

operation Attendee isSittingNextToCommonLanguage(): Boolean {
	var neighbours = self.mySeat.GetNeighbours();
	if (neighbours.size() > 0){
		return self.spokenLanguages.exists(sl | neighbours.spokenLanguages.flatten().includes(sl));}
	else {return false;}
}

operation Attendee IsOnSameTableAs(target: Attendee): Boolean {
	return self.mySeat.myTable.seats.attendeeSeat.includes(target);
}

operation Attendee GetFailedWishes(): Map {
	var atSeats = self.mySeat.myTable.seats.attendeeSeat;
	var failedWishes = self.anttendeeWishes
						.select(aW | (aW.wish.literal == "Dislike" and atSeats.includes(aW.targetAttendee))
									 or
									 (aW.wish.literal == "Like" and not atSeats.includes(aW.targetAttendee)))
						.aggregate(aW | aW.targetAttendee, aW.wish);
	return failedWishes;
	
}

operation AttendeeWish GetAttendeeFromListBarSelf(): Sequence {
	var possibleAttendees = Attendee.all.reject(a | a == self.sourceAttendee);
	var att = System.user.choose("Choose attendees", possibleAttendees);
	var toReturn = null;
	if (att.isDefined()){toReturn = att;}
	else {System.user.inform("You have chosen no attendee");}
	return toReturn;
}


operation SeatingPlan getAllFailures(): Map {
	var failed = new Map;
	var failedWishes = new Map;
	var failedLanguages = new Map;
	
	for (at in self.attendees){
		var fails = at.GetFailedWishes();
		if (fails.size() > 0){failedWishes.put(at, fails);}
		if (at.isSittingNextToCommonLanguage()){failedLanguages.put(at, false);}
	}
	if (failedWishes.size()>0) failed.put('failedWishes', failedWishes); // att, (targetAtt, wish)
	if (failedLanguages.size()>0) failed.put('failedLanguages', failedLanguages); // att, boolean
	return failed;
}

operation Set<Attendee> hasUniqueLanguage(): Set {
	var langs = self.spokenLanguages.flatten();
	return langs.asSet().select(l | langs.count(l) == 1);
}

operation Out!SeatingPlan preliminaryCheckIsImpossible(): Boolean {

	for (at in self.attendees){
		// Check if any attendee can't speak to someone else
		var otherLang = self.attendees.excluding(at).spokenLanguages.flatten().name;
		if (not at.spokenLanguages.flatten().name.exists(l | otherLang.includes(l))){
			var msg = at.firstName + " " + at.lastName + " speaks language(s) that no one else understands.";
			System.user.inform(msg);
			return true;
		}
		
		// Check if any attendee likes someone who doesn't like them back
		for (_wish in at.anttendeeWishes){
			if (_wish.wish.literal == "Like" 
				and _wish.targetAttendee.anttendeeWishes.exists(w | w.targetAttendee == at and w.wish.literal == "Dislike")){
					var msg = at.firstName + " " + at.lastName + " has conflicting wishes with " + _wish.targetAttendee.firstName + " " + _wish.targetAttendee.lastName;
					System.user.inform(msg);
					return true;
				}
		}
	}
	return false;
}

operation Out!Attendee getLikedPeople(): Set {
	return self.anttendeeWishes.select(at|at.wish.literal == "Like").targetAttendee.asSet();//.excludingAll(currentList);
}

operation Out!Attendee getGroupForAttendee() {
	var baseAr = new Set;
	baseAr.add(self);
	var likeAr = baseAr.clone();	
	while (likeAr.size() > 0){
		var nextGen = new Set;
		for (at in likeAr){
			var newPeop = at.getLikedPeople();
			nextGen.addAll(newPeop);
		}
		likeAr = nextGen.excludingAll(baseAr).clone();
		baseAr.addAll(likeAr.clone());
	}
	return baseAr;
}


operation Out!SeatingPlan sortAttendees(): SeatingPlan {
	/*
	Clone all the attendees into a set then order them by uid
	whilst there is people still in that set, get the result from the getAllInGroup fn
	Remove the people in the result from the original cloned attendeeList
	Build up a set of sets of people that must sit with each other
	*/
	var oAttendees = self.attendees.clone().asSet().sortBy(a|a.uID);
	var gAttendees = new Sequence();

	// This sets up groups of people who want to sit together but doesn't have duplicates
	while (oAttendees.size() > 0){
		var chosenAtt = oAttendees[0];
		var _group = chosenAtt.getGroupForAttendee().asSet();
		_group = _group.excludingAll(gAttendees.flatten());
		gAttendees.add(_group);
		oAttendees = oAttendees.excludingAll(_group);
	}
	
	// This will join people who are on their own into groups where no one dislikes them
	var onePersonSets = gAttendees.select(set|set.size() == 1);
	var notOnePersonSets = gAttendees.select(set|set.size() > 1);
	
	for (notOneSet in notOnePersonSets){
		for (oneSet in onePersonSets){
			if (not notOneSet.anttendeeWishes.flatten().select(at|at.wish.literal == "Dislike").targetAttendee.asSet().includes(oneSet[0])){
				notOneSet.add(oneSet[0]);
				oneSet.clear();
			}
		}
	}
	onePersonSets = gAttendees.select(set|set.size() == 1);
	notOnePersonSets = gAttendees.select(set|set.size() > 1);
	
	// This will add people who are on their own into anywhere they can find someone who can speak a language
	for (notOneSet in notOnePersonSets){
		for (oneSet in onePersonSets){
			if (notOneSet.spokenLanguages.flatten().exists(l| oneSet[0].spokenLanguages.includes(l))){
				notOneSet.add(oneSet[0]);
				oneSet.clear();
			}
		}
	}
	gAttendees = gAttendees.select(set|set.size()>0);
	
	
	var i = 0;
	var cap = gAttendees.collect(s|s.size()).max();
	var tables = new Set();
	for (set in gAttendees){
		set.println();
		var uniqueLangs = set.hasUniqueLanguage();
		if (uniqueLangs.size() > 0){
			// Check if that language is spoken on another table
			// If not, then no one speasks it
			// If so, move them to their table despite preferences.
			// Language always above preferences.
			(uniqueLangs + "are the languages that are only spoken by one person").println();
			for (lang in uniqueLangs){
				var attendee = set.select(at|at.spokenLanguages.includes(lang));
				if (attendee.isDefined()){
					var tablesWithLang = gAttendees.excluding(set).select(st| st.exists(at|at.spokenLanguages.includes(lang)));
					if (tablesWithLang.size() > 0){
						tablesWithLang[0].add(attendee);
						set.remove(attendee);
					}
				}
			}
		}
		
		// Sort everyone by their languages
		// Seat them all down that way so at least one person speaks the same language as you do
		// Create a new seat for each of them around the table
		set = set.sortBy(a|a.spokenLanguages.sortBy(l|l.name));
		var newTable = new Out!Table(uID=i, capacity=cap);
		var index = 0;
		var seats = new Set();
		for (at in set){
			var seat = new Out!Seat();
			seat.myTable = newTable;
			seat.attendeeSeat = at;
			seat.uID = index;
			index += 1;
			seats.add(seat);
		}
		newTable.seats = seats.println();
		tables.add(newTable);
		i += 1;
	}
	self.tables = tables;
}
















