pre {
	var tables = Table.all;
	var i = 0; 
  	for (el in tables) {
  		el.tableID = i; i += 1;
  	}
}



context SeatingPlan {

  constraint HasName {
      	check : self.seatingPlanName.isDefined()
      	message : 'Unnamed Seating Plan "' + self.eClass().name + '" not allowed'
      	fix {
          title : 'Add Seating Plan name to ' + self.eClass().name
          do {
              var name := System.user.prompt('Input name of seating plan');
              if (name.isDefined()) self.seatingPlanName := name;
          }

      }
  }
  
  
  critique NameStartsWithCapital  {
  		guard : self.satisfies('HasName')
  		check : self.seatingPlanName.firstToUpperCase() = self.seatingPlanName
  		message : 'SeatingPlan "' + self.seatingPlanName +
          '" should start with an upper-case letter'
  		fix {
          title : 'Rename to ' + self.seatingPlanName.firstToUpperCase()
          do {
              self.seatingPlanName := self.seatingPlanName.firstToUpperCase();
          }
      }
  		
  }
  
 constraint TableIdUnique {
 		guard: self.satisfies('NameStartsWithCapital')
		check: self.tables.tableID.size() == self.tables.tableID.asSet().size()
		message: "All table IDs must be unique"
		fix {
			title: "Auto-generate IDs for all the tables"
			do {
				var i = 0; 
          		for (el in self.tables) {
          			el.tableID = i; i += 1;}
			}
		}
	}
	
	
	constraint AllergyUnique {
		check: self.allergies.foodAllergyName.size() == self.allergies.foodAllergyName.asSet().size()
		message: "Should not have duplicate names for food allergies"
		fix {
			title: "Delete the duplicates"
			do {
				var allergies: Set<FoodAllergy>;
				for (alle in self.allergies){
					if (not allergies.exists(el |el.foodAllergyName == alle.foodAllergyName)){
						allergies.add(alle);
					}
				}
				self.allergies = allergies;
			}
		}
	}
	
	
	constraint LanguageUnique {
		check: self.languages.languageName.size() == self.languages.languageName.asSet().size()
		message: "Should not have duplicate names for languages"
		fix {
			title: "Delete the duplicates"
			do {
				for (lang in self.languages){
					var dup = self.languages.select(l | l.languageName == lang.languageName);
					if (dup.size() > 1){delete(lang);}
				}
			}
		}
	}

}


context Attendee {

	constraint HasAttendeeID {
		check: self.attendeeID.isDefined()
		fix {
			title: "Auto generating attendee ID"
			do {
				var i =0;
				for (a in SeatingPlan.attendees){
					a.attendeeID = i;
				}
			}
		}
	}

  constraint HasFirstAndLastName {
  		guard: self.satisfies('HasAttendeeID')
      	check : self.firstName.isDefined() and self.lastName.isDefined()
      	message : 'Attendee "' + self.eClass().name + '" must have a first name and a second name'
		fix {
          title : 'Ensure there is both a first and last name for ' + self.eClass().name
          do {
          
          		if (not self.firstName.isDefined()) {
          			var firstName = System.user.prompt('Input First Name');
          			if (firstName.isDefined()) self.firstName := firstName;
          		}
          		
          		if (not self.lastName.isDefined()) {
          			var lastName = System.user.prompt('Input Last Name');
          			if (lastName.isDefined()) self.lastName := lastName;
          		}
          }

      }
  }
  
  
  critique NamesStartWithCapitals  {
  
  		guard : self.satisfies('HasFirstAndLastName')
  		
  		check : self.firstName.firstToUpperCase() = self.firstName and
  				self.lastName.firstToUpperCase() = self.lastName
  		
  		message : "First Name: '" + self.firstName + 
  					"' and Last Name: '" + self.lastName + 
  					"' both should start with an upper-case"
  		
  		fix {

          title : 'Rename to ' + self.firstName.firstToUpperCase() + " " + self.lastName.firstToUpperCase()

          do {
              self.firstName := self.firstName.firstToUpperCase();
              self.lastName := self.lastName.firstToUpperCase();
          }
      }
  		
  }
  
  constraint HasLanguage {
  		guard : self.satisfies('HasFirstAndLastName')
  		
  		check: self.spokenLanguages.size() > 0
  		
  		message : self.firstName + " " + self.lastName + " must speak at least one language"
  		
  		fix {
  			title: "Add a spoken language for " + self.firstName + " " + self.lastName 
  			
  			do {
  				if (Language.All.size() > 0){
  					var chosenLanguages = System.user.chooseMany("Choose languages", Language.All);
					if (chosenLanguages.size() > 0) {
						for (l in chosenLanguages){
							self.spokenLanguages.add(l);
						}
					} 
  				} else {
  					System.user.inform("There are no languages instatiated. Please add a language to the Model first.");
  				}
  				
  			}
  		}	
  }
  
  constraint SeatIsDefined {
  		guard: self.satisfies('HasLanguage')
  		check: self.mySeat.isDefined()
  		message: self.firstName + " " + self.lastName + " must have a allocated seat."
  		fix {
  			title: "Choose a seat for the attendee"
  			do {
  				var chosenTable = System.user.choose("Choose which table", Table.All);
  				
  				if (chosenTable.isDefined()){
  					var availableSeats = chosenTable.seats.select(s | not s.attendeeSeat.isDefined());
  					if (availableSeats.size() > 0){
  						var chosenSeat = System.user.choose("Choose which seat", availableSeats);
  						if (chosenSeat.isDefined()) self.mySeat = chosenSeat;	
  					}
  					else System.user.inform("There are no available seats at this table. Add a seat to assign this attendee.");
  				}
  			}
  		}
  }
  
  constraint AttendeeSatWithLanguage {
		guard: self.satisfies('SeatIsDefined')
		check {
			var selfSeat = self.mySeat;
			var neighbours = selfSeat.myTable.seats.select(s | s.attendeeSeat.isDefined() and (s.index == selfSeat.index + 1 or s.index == selfSeat.index - 1)).attendeeSeat;
			if (neighbours.size() > 0){
				return self.spokenLanguages.exists(sl | neighbours.spokenLanguages.flatten().includes(sl));}
			else {return false;}
		}
		message: self.firstName + " " + self.lastName + " isn't sitting next to someone that can speak their language"
	}
	
	
	constraint DifferentWishesOnSamePerson {
		check {
			for (attWish in self.anttendeeWishes){
				var dup = self.anttendeeWishes.select(aW | aW.targetAttendee == attWish.targetAttendee).wish.literal;
				if (dup.size() > 1){
					if (dup.includes("Like") and dup.includes("Dislike")){
						return false;
					}
				}
			} return true;
		}
		message: self.firstName + " " + self.lastName + " has conflicting wishes for the same person"
		fix {
			title: "Remove conflicting wishes"
			do {
				var newAttendeeList: Sequence;
				var aWishNumbers = self.anttendeeWishes.aggregate(aW | aW.targetAttendee, self.anttendeeWishes.select(aW2 | aW2.targetAttendee == aW.targetAttendee));
				
				for (attendee in aWishNumbers.keySet()){
				
					if (aWishNumbers.get(attendee) > 1){
						var choice = System.user.choose("Choose Like or Dislike for " + attendee.firstName + " " + attendee.lastName, Sequence{"Like", "Dislike"});
						self.anttendeeWishes = self.anttendeeWishes.reject(aW | aw.targetAttendee == attendee);
						self.anttendeeWishes.add(new AttendeeWish(sourceAttendee=self, targetAttendee = attendee, wish=choice));
					}
				}
				self.anttendeeWishes = newAttendeeList;
			}
		}
	}
  
}



context Table {
	
	constraint HasCapacity {
		check : self.capacity.isDefined() and self.capacity > 1
		message : 'Table "' + self.eClass().name + '" must have a capacity'
		fix {
          title : 'Set the capacity for the table'
          do {
          		var capacity = System.user.promptInteger("Input the table's capacity");
          		if (capacity.isDefined()) self.capacity = capacity;
          }
      }
	}
	
	
	constraint HasAtLeastOneAttendee {
	
		guard : self.satisfies('HasCapacity')
		check: self.seats.size() >= 1
		message: "Table " + self.tableID + " has not got any seats"
		
		fix {
		
			title: "Either add a seat or remove table " + self.tableID + " from the seating plan"

			do {
				var options = Sequence{"Remove table", "Add seat"};				
				var option = System.user.choose("Choose an option", options);
			
				if (option == "Remove table"){
					delete(self);
				}
				
				if (option == "Add seat"){
					if (Attendee.all.size() > 0){
						var chosenAttendee = System.user.choose("Choose attendee", Attendee.all);
						if (chosenAttendee.isDefined()) {
							self.seats.add(new Seat(index=1, attendeeSeat=chosenAttendee));
						} else {
							System.user.inform("You must choose an attendee");}
					} else {
						System.user.inform("There are no attendees created. Please add an attendee first");}
				}
			
			}
		}
	
	}
	
	constraint UniqueSeat {
		guard: self.satisfies('HasAtLeastOneAttendee')
		check: self.seats.index.size() == self.seats.index.asSet().size()
		message: "All seats on table " + self.tableID + " must be unique. Arange the seats and attendees accordingly."
	}
	
}

context Seat {

	constraint HasIndex {
		check: self.index.isDefined()
		message: "The Seat '" + self.eClass().name + "' must have an index"
		
		fix {
			title: "Creating index for the seat"
			do {
				self.index = self.parent.seats.index.max(0) + 1;
			}
		}
	}
	
	constraint HasAttendee {
		guard: self.satisfies('HasIndex')
		check: self.attendeeSeat.isDefined()
		message: "The Seat '" + self.eClass().name + "' must have an assigned attendee"
		fix {
			title: "Choose the attendee"
			do {
				var chosenAttendee = System.user.choose("Choose attendee", Attendee.all);
				if (chosenAttendee.size() > 0) self.attendeeSeat = chosenAttendee;
			}
		}
	}
}

context AttendeeWish {

	constraint HasReferencedAttendee {
		check: self.targetAttendee.isDefined()
		message: "There must be a referenced attendee"
		fix {
			title: "Choose the attendee"
			do {
				var possibleAttendees = Attendee.all.reject(a | a == self.sourceAttendee);
				var chosenAttendee = System.user.choose("Choose attendees", possibleAttendees);
				if (chosenAttendee.isDefined()) self.targetAttendee = chosenAttendee;
			}
		}
	}
	
	constraint HasWish {
		guard: self.satisfies('HasReferencedAttendee')
		check: self.wish.isDefined()
		message: "There must be a wish defined"
		fix {
			title: "Choose the attendee"
			do {
				var feeling = System.user.choose("Choose feeling", Feeling);
				if (feeling.isDefined()) self.wish = feeling;
			}
		}
	}
	
	constraint AttendeeIsNotSelf {
		guard: self.satisfies('HasWish')
		check: self.targetAttendee <> self.sourceAttendee
		message: "Cannot assign a feeling to the same person"
		fix {
			title: "Choose another attendee"
			do {
				var possibleAttendees = Attendee.all.reject(a | a == self.sourceAttendee);
				var chosenAttendee = System.user.choose("Choose attendees", possibleAttendees);
				if (chosenAttendee.isDefined()) self.targetAttendee = chosenAttendee;
			}
		}
	}
	
	critique AttendeeSatWithDislike {
		guard: self.satisfies('AttendeeIsNotSelf')
		check {
			var selfSeat = self.sourceAttendee.mySeat;
			var neighbours = selfSeat.myTable.seats.attendeeSeat;
			return not (neighbours.includes(self.targetAttendee) and self.wish.literal == "Dislike");
		}
		message: self.sourceAttendee.firstName + " " + self.sourceAttendee.lastName 
				+ " is sitting on a table with someone they dislike"
	}
	
	critique AttendeeSatWithLike {
		guard: self.satisfies('AttendeeIsNotSelf')
		check {
			if (self.wish.literal == "Like"){
				var selfSeat = self.sourceAttendee.mySeat;
				var neighbours = selfSeat.myTable.seats.attendeeSeat;
				return neighbours.includes(self.targetAttendee);
			} else {return true;}
		}
		message: self.sourceAttendee.firstName + " " + self.sourceAttendee.lastName 
				+ " isn't sitting on the same table as someone they liked"
	}
}

context Language {

	constraint IsDefined {
		check: self.languageName.isDefined()
		message: "Language isn't defined"
		fix {
			title: "Set language name"
			do {
				var name = System.user.prompt("Input language name");
				if (name.isDefined()) self.languageName = name;
			}
		}	
	}
	
	critique NameStartsWithCapital  {
  		guard : self.satisfies('IsDefined')
  		check : self.languageName.firstToUpperCase() = self.languageName
  		message : 'Language Name "' + self.languageName +
          '" should start with an upper-case letter'
  		fix {
          title : 'Rename to ' + self.languageName.firstToUpperCase()
          do {
              self.languageName := self.languageName.firstToUpperCase();
          }
      }
  }

}


context FoodAllergy {
	constraint IsDefined {
		check: self.foodAllergyName.isDefined()
		message: "Food Allergy isn't defined"
		fix {
			title: "Set allergy name"
			do {
				var name = System.user.prompt("Input allergy name");
				if (name.isDefined()) self.foodAllergyName = name;
			}
		}
	}
	
	critique NameStartsWithCapital  {
  		guard : self.satisfies('IsDefined')
  		check : self.foodAllergyName.firstToUpperCase() = self.foodAllergyName
  		message : 'Allergy Name "' + self.foodAllergyName +
          '" should start with an upper-case letter'
  		fix {
          title : 'Rename to ' + self.foodAllergyName.firstToUpperCase()
          do {
              self.foodAllergyName := self.foodAllergyName.firstToUpperCase();
          }
      }
  }
}
